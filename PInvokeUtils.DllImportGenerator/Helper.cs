using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Syntax = Microsoft.CodeAnalysis.CSharp.SyntaxFacts;

namespace PlatformInvokeGenerator;

internal class Helper
{
    public const string ATTRIBUTES = """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by the PlatformInvokeGenerator source generator
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------

        using System;
        using System.Runtime.InteropServices;


        namespace PlatformInvokeGenerator
        {
            #pragma warning disable CS0649 //Field 'field' is never assigned to, and will always have its default value 'value'        
            #nullable enable
            public enum ImportPlatform
            {
                Win32,
                Win64,
                Linux64,
                Osx
            }

            public enum AccessModifiers
            {
                Public,
                Protected,
                Internal,
                Private,
                ProtectedInternal,
                PrivateProtected,
            }

            /// <summary>
            /// Indicates that the attributed method is exposed by an unmanaged dynamic-link library (DLL) as a static entry point.
            /// An extern methods will be generated for each attribute. 
            /// One common method that can be called will be generated, when call, this method will decide what platform-specific extern method to call.
            /// </summary>
            [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)]
            internal class DllImportForAttribute : Attribute
            {
                /// <summary>
                /// Constructor
                /// </summary>
                /// <param name="dllName">Library path and name, same value as if this was normal DllImport attribute</param>
                /// <param name="platform">Target platform</param>
                public DllImportForAttribute(string dllName, ImportPlatform platform)
                {
                    DllName = dllName;
                    Platform = platform;
                }
                /// <summary>
                /// Library name (and path)
                /// </summary>
                public string DllName { get; }
                /// <summary>
                /// Target platform
                /// </summary>
                public ImportPlatform Platform { get; }
                /// <summary>
                /// Native method entrypoint
                /// </summary>
                public string? EntryPoint;
                /// <summary>
                /// Native method calling convention, default value is Cdecl
                /// </summary>
                public CallingConvention CallingConvention;
                /// <summary>
                /// Is the generated call method static
                /// </summary>
                public bool StaticCallMethod;
                /// <summary>
                /// CharSet value that is used as CharSet value in generated DllImport
                /// </summary>
                public CharSet CharSet;
                /// <summary>
                /// SetLastError, same behavior as standard DllImport
                /// </summary>
                public bool SetLastError;
            }

            /// <summary>
            /// Marks this class as extern class, this class will be used as source class for the PlatformInvokeGenerator source generator.
            /// </summary>
            [AttributeUsage(AttributeTargets.Class)]
            internal class ExternClassAttribute : Attribute
            {
                /// <summary>
                /// Name of the generated class. If value is not provided, name of the decorated class will be used, the decorated class must be partial for this use.
                /// </summary>
                public string? GeneratedClassName;
                /// <summary>
                /// Namespace where the generated class will live. This value is used only if the GeneratedClassName is provided.
                /// </summary>
                public string? GeneratedClassNamespace;
                /// <summary>
                /// Generated class visibility modifier. This value is used only if the GeneratedClassName is provided. Default value is Internal.
                /// </summary>
                public AccessModifiers ClassAccessModifier;
                /// <summary>
                /// Visibility of the call methods. Default value is Internal.
                /// </summary>
                public AccessModifiers CallMethodsAccessModifier;
                /// <summary>
                /// Set to true if you want the generated class to be static, default value is false.
                /// </summary>
                public bool GenerateStaticClass;
                /// <summary>
                /// Set to true if you want the generated class to be marked as unsafe, default value is false.
                /// </summary>
                public bool GenerateUnsafeClass;
            }
        }       
        
        """;
    public const string DLL_IMPORT_FOR_ATTRIBUTE_NAME = "PlatformInvokeGenerator.DllImportForAttribute";
    public const string EXTERN_CLASS_ATTRIBUTE_NAME = "PlatformInvokeGenerator.ExternClassAttribute";
    public const string NAME = "Name";
    public const string GLOBAL_NAMESPACE = "<global namespace>";
    public const string NAMESPACE = "Namespace";

    public static unsafe string GenerateExternClass(in ClassInfo cl)
    {
        var hasNamespace = !string.IsNullOrEmpty(cl.Namespace);
        var sb = new StringBuilder();
        sb.Append($$"""
            //------------------------------------------------------------------------------
            // <auto-generated>
            //     This code was generated by the PlatformInvokeGenerator source generator
            //
            //     Changes to this file may cause incorrect behavior and will be lost if
            //     the code is regenerated.
            // </auto-generated>
            //------------------------------------------------------------------------------

            {{cl.UsingNamespaces}} 
            
            """);
        if (!cl.UsingNamespaces.Contains("using System;"))
            sb.AppendLine("using System;");
        if (!cl.UsingNamespaces.Contains("using System.Runtime.InteropServices;"))
            sb.AppendLine("using System.Runtime.InteropServices;");



        sb.AppendLine();
        sb.AppendLine("#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.");
        sb.AppendLine("#pragma warning disable CS8625 // Cannot convert null literal to non-nullable reference type.");
        sb.AppendLine("#nullable enable");

        //namespace start
        if (hasNamespace)
        {
            sb.AppendLine($$"""
                namespace {{cl.Namespace}}
                {
                """);
        }

        //class start
        //sb.AppendLine($$"""
        //       {{GetAccessModifier(cl.ClassAccessModifier)}}{{(cl.GenerateStaticClass ? " static" : "")}}{{(cl.GenerateUnsafeClass ? " unsafe" : "")}} partial class {{cl.GeneratedClassName}}
        //       {
        //    """);
        sb.Append(GetAccessModifier(cl.ClassAccessModifier));
        if (cl.GenerateStaticClass)
            sb.Append(" static");
        if (cl.GenerateUnsafeClass)
            sb.Append(" unsafe");
        sb.Append(" partial class ");
        sb.AppendLine(cl.GeneratedClassName);
        sb.AppendLine("{");
        //class body
        var callMethodVisibility = GetAccessModifier(cl.MethodsAccessModifier);
        foreach (var methodCollection in cl.Methods)
        {
            bool win32 = false, win64 = false, linux64 = false, osx = false;
            string implSuffix = (cl.IsDecoratedClassPartial && cl.GeneratedClassName == cl.SourceClassName) ? "Impl" : "";

            foreach (var method in methodCollection)
            {
                //-----START DllImport-----
                sb.Append($$"""
                            [DllImport(@"{{method.DllName}}", EntryPoint = "{{method.EntryPoint}}"
                    """);
                if (method.CharSet is not CharSet.None and not CharSet.Ansi)
                    sb.Append($", CharSet = CharSet.{method.CharSet}");
                if (method.SetLastError)
                    sb.Append(", SetLastError = true");
                sb.AppendLine(")]");
                //-----END DllImport-----

                if (!string.IsNullOrEmpty(method.ReturnTypeAttributes))
                    sb.AppendLine($$"""
                                [return: {{method.ReturnTypeAttributes}}]
                        """);
                sb.AppendLine($$"""
                            private static extern {{method.ReturnType}} __{{method.Platform}}_{{method.NameWithoutPlatform}}({{method.Parameters}});

                    """);

                switch (method.Platform)
                {
                    case ImportPlatform.Win32:
                        win32 = true;
                        break;
                    case ImportPlatform.Win64:
                        win64 = true;
                        break;
                    case ImportPlatform.Linux64:
                        linux64 = true;
                        break;
                    case ImportPlatform.Osx:
                        osx = true;
                        break;
                    default:
                        break;
                }
            }

            var platforms = new CurrentPlatforms(win32, win64, linux64, osx);

            var l_method = methodCollection[0];
            //method start (method signature)
            sb.AppendLine($$"""
                            {{callMethodVisibility}}{{(l_method.IsStatic ? " static" : "")}} {{l_method.ReturnType}} {{l_method.NameWithoutPlatform}}{{implSuffix}}({{l_method.Parameters}})
                            {
                    """);
            var @return = l_method.ReturnType == "void" ? "" : " return";
            //if only one platform the runtime checks for current platform are skipped
            if (platforms.Count == 1)
            {
                sb.AppendLine($$"""
                                {{@return}} __{{platforms.GetFirstPlatform()}}_{{l_method.NameWithoutPlatform}}({{l_method.ParametersNames}});
                    """);
            } //if only windows is imported the current platform checks are also skipped
            else if (platforms.IsWindows32and64Only())
            {
                sb.AppendLine($$"""
                                if(Environment.Is64BitProcess)
                                {
                                   {{@return}} __{{ImportPlatform.Win64}}_{{l_method.NameWithoutPlatform}}({{l_method.ParametersNames}});
                                }
                                else
                                {
                                   {{@return}} __{{ImportPlatform.Win32}}_{{l_method.NameWithoutPlatform}}({{l_method.ParametersNames}});
                                }
                                
                    """);
            }
            else
            {
                var enumerator = platforms.GetEnumerator();
                enumerator.MoveNext();
                //first platform, starting with if
                if (enumerator.Current == ImportPlatform.Win32 && platforms.Win64)
                {
                    //skip Win64
                    enumerator.MoveNext();
                    //windonws specific bitness check
                    sb.AppendLine($$"""
                                    if(RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                                    {
                                        if(Environment.Is64BitProcess)
                                        {
                                           {{@return}} __{{ImportPlatform.Win64}}_{{l_method.NameWithoutPlatform}}({{l_method.ParametersNames}});
                                        }
                                        else
                                        {
                                           {{@return}} __{{ImportPlatform.Win32}}_{{l_method.NameWithoutPlatform}}({{l_method.ParametersNames}});
                                        }
                                    }
                        """);
                }
                else
                    sb.AppendLine($$"""
                                if(RuntimeInformation.IsOSPlatform(OSPlatform.{{platforms.ToOsPlatformString(enumerator.Current)}}))
                                {
                                    {{@return}} __{{enumerator.Current}}_{{l_method.NameWithoutPlatform}}({{l_method.ParametersNames}});
                                }
                        """);

                while (enumerator.MoveNext())
                {
                    sb.AppendLine($$"""
                                    else if(RuntimeInformation.IsOSPlatform(OSPlatform.{{platforms.ToOsPlatformString(enumerator.Current)}}))
                                    {
                                        {{@return}} __{{enumerator.Current}}_{{l_method.NameWithoutPlatform}}({{l_method.ParametersNames}});
                                    }
                        """);
                }

                sb.AppendLine("""
                                else
                                    throw new NotSupportedException("Current OSPlatform is not supported");
                    """);
            }
            //method end
            sb.AppendLine("""
                        }

                """);
        }

        //class end
        sb.AppendLine("""
               }
            """);
        //namespace end
        if (hasNamespace)
            sb.AppendLine("""
            }
            #pragma warning restore CS8625 // Cannot convert null literal to non-nullable reference type.
            #pragma warning restore CS8600 // Converting null literal or possible null value to non-nullable type.
            """);

        return sb.ToString();
    }

    public static void AppendMethodParameters(IMethodSymbol method, StringBuilder sb)
    {
        for (var i = 0; i < method.Parameters.Length; i++)
        {
            IParameterSymbol? param = method.Parameters[i];
            var atrs = param.GetAttributes();
            var hasAttributes = atrs.Length > 0;

            if (hasAttributes)
                sb.Append('[');

            for (var y = 0; y < atrs.Length; y++)
            {
                AttributeData? atr = atrs[y];
                sb.Append(AttributeToSpan(atr, out var @namespace).ToString());
                if (y != atrs.Length - 1)
                    sb.Append(", ");
            }

            if (hasAttributes)
                sb.Append("] ");
            sb.Append(param.ToString());

            if (param.HasExplicitDefaultValue)
            {
                sb.Append(" = ");
                sb.Append('(');
                sb.Append(param.Type.ToString());
                sb.Append(')');
                if (param.Type.SpecialType == SpecialType.System_String && param.ExplicitDefaultValue is not null)
                {
                    sb.Append('"');
                    sb.Append(param.ExplicitDefaultValue);
                    sb.Append('"');
                    //sb.Append($"\"{param.ExplicitDefaultValue}\"");
                }
                else
                    sb.Append(param.ExplicitDefaultValue ?? "null");
            }

            if (i != method.Parameters.Length - 1)
                sb.Append(", ");
        }
    }

    public static ReadOnlySpan<char> AttributeToSpan(AttributeData atr, out HashSet<string> namespaces)
    {
        namespaces = new();
        var sb = new StringBuilder();
        sb.Append(atr.AttributeClass!.Name);
        _ = namespaces.Add(atr.AttributeClass.ContainingNamespace.ToDisplayString());
        sb.Append('(');

        for (var i = 0; i < atr.ConstructorArguments.Length; i++)
        {
            TypedConstant arg = atr.ConstructorArguments[i];
            _ = namespaces.Add(arg.Type!.ContainingNamespace.ToDisplayString());
            if (arg.Type!.TypeKind == TypeKind.Enum)
            {
                sb.Append('(');
                sb.Append(arg.Type.Name);
                sb.Append(')');
            }
            else if (arg.Value is not null && arg.Type.SpecialType == SpecialType.System_String)
            {
                sb.Append('"');
            }

            sb.Append(arg.Value ?? "null");

            if (arg.Value is not null && arg.Type.SpecialType == SpecialType.System_String)
            {
                sb.Append('"');
            }

            if (i != atr.ConstructorArguments.Length - 1)
                sb.Append(", ");
        }
        if (atr.ConstructorArguments.Length > 0 && atr.NamedArguments.Length > 0)
            sb.Append(", ");
        for (var i = 0; i < atr.NamedArguments.Length; i++)
        {
            var arg = atr.NamedArguments[i];
            _ = namespaces.Add(arg.Value.Type!.ContainingNamespace.ToDisplayString());
            sb.Append(arg.Key);
            sb.Append(" = ");
            if (arg.Value.Type.TypeKind == TypeKind.Enum)
            {
                sb.Append('(');
                sb.Append(arg.Value.Type.Name);
                sb.Append(')');
            }
            else if (arg.Value.Value is not null && arg.Value.Type.SpecialType == SpecialType.System_String)
            {
                sb.Append('"');
            }
            sb.Append(arg.Value.Value ?? "null");
            if (arg.Value.Value is not null && arg.Value.Type.SpecialType == SpecialType.System_String)
            {
                sb.Append('"');
            }
            if (i != atr.NamedArguments.Length - 1)
                sb.Append(", ");
        }

        sb.Append(')');
        var l = atr.ApplicationSyntaxReference!.Span;
        var buf = new char[l.Length];
        atr.ApplicationSyntaxReference.SyntaxTree.GetText().CopyTo(l.Start, buf, 0, l.Length);
        return new ReadOnlySpan<char>(buf);
    }

    public static List<AttributeData> ExtractDllImportrForAttributes(ISymbol member, out bool hasDllImport)
    {
        var dllImportFors = new List<AttributeData>();
        hasDllImport = false;

        foreach (var atr in member.GetAttributes())
        {
            if (atr.AttributeClass?.Name == nameof(DllImportAttribute))
            {
                hasDllImport = true;
                continue;
            }
            if (atr.AttributeClass?.Name == nameof(DllImportForAttribute))
            {
                dllImportFors.Add(atr);
                continue;
            }
        }

        return dllImportFors;
    }

    static string GetAccessModifier(AccessModifiers mod)
        => mod switch
        {
            AccessModifiers.Public => "public",
            AccessModifiers.Protected => "protected",
            AccessModifiers.Internal => "internal",
            AccessModifiers.Private => "private",
            AccessModifiers.ProtectedInternal => "protected internal",
            AccessModifiers.PrivateProtected => "private protected",
            _ => throw new NotImplementedException(),
        };

    public static ClassInfo GetClassInfo(INamedTypeSymbol symbol, in SyntaxTokenList syntaxTokens)
    {
        var sourceClassIsPartial = false;
        var isUnsafe = false;
        foreach (var token in syntaxTokens)
        {
            if (token.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword))
            {
                sourceClassIsPartial = true;
                continue;
            }
            if (token.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.UnsafeKeyword))
            {
                isUnsafe = true;
                continue;
            }
        }
        foreach (var atr in symbol.GetAttributes())
        {
            if (atr.AttributeClass?.Name != nameof(ExternClassAttribute) && atr.AttributeClass?.ContainingNamespace.Name != nameof(PlatformInvokeGenerator)
                && atr.AttributeClass?.ContainingNamespace.ContainingNamespace.Name != Helper.GLOBAL_NAMESPACE)
                continue;

            string? className = null;
            var @namespace = GetNamespace(symbol);
            var isStatic = false;
            AccessModifiers access = AccessModifiers.Internal;
            AccessModifiers callMethodAccessModifier = AccessModifiers.Internal;

            foreach (var arg in atr.NamedArguments)
            {
                switch (arg.Key)
                {
                    case nameof(ExternClassAttribute.GeneratedClassName):
                        className = arg.Value.Value?.ToString();
                        continue;
                    case nameof(ExternClassAttribute.GeneratedClassNamespace):
                        var v = (string)arg.Value.Value!;
                        if (!ErrorHelper.IsNamespaceInvalid(v))
                            @namespace = v;
                        continue;
                    case nameof(ExternClassAttribute.ClassAccessModifier):
                        access = (AccessModifiers)arg.Value.Value!;
                        continue;
                    case nameof(ExternClassAttribute.CallMethodsAccessModifier):
                        callMethodAccessModifier = (AccessModifiers)arg.Value.Value!;
                        continue;
                    case nameof(ExternClassAttribute.GenerateStaticClass):
                        isStatic = (bool)arg.Value.Value!;
                        continue;
                    case nameof(ExternClassAttribute.GenerateUnsafeClass):
                        isUnsafe = (bool)arg.Value.Value!;
                        continue;
                    default:
                        continue;
                }
            }

            if (sourceClassIsPartial && string.IsNullOrEmpty(className))
            {
                className = symbol.Name;
                isStatic = symbol.IsStatic;
                @namespace = GetNamespace(symbol);
                access = symbol.DeclaredAccessibility switch
                {
                    Accessibility.NotApplicable => AccessModifiers.Internal,
                    Accessibility.Private => AccessModifiers.Private,
                    Accessibility.ProtectedAndInternal => AccessModifiers.ProtectedInternal,
                    Accessibility.Protected => AccessModifiers.Protected,
                    Accessibility.Internal => AccessModifiers.Internal,
                    Accessibility.ProtectedOrInternal => AccessModifiers.ProtectedInternal,
                    Accessibility.Public => AccessModifiers.Public,
                    _ => AccessModifiers.Internal,
                };
            }


            //var usings = atr.ApplicationSyntaxReference!.SyntaxTree.GetRoot()
            //                                                       .DescendantNodes()
            //                                                       .OfType<UsingDirectiveSyntax>()
            //                                                       .Select(x => x.NamespaceOrType.ToString())
            //                                                       .ToList();
            return new ClassInfo(symbol.Name,
                                 className!,
                                 @namespace,
                                 new List<List<MethodInfo>>(),
                                 access,
                                 isStatic,
                                 new HashSet<string>(),
                                 atr.ApplicationSyntaxReference!.Span,
                                 callMethodAccessModifier,
                                 atr.ApplicationSyntaxReference!.SyntaxTree.GetLineSpan(atr.ApplicationSyntaxReference!.Span),
                                 sourceClassIsPartial,
                                 isUnsafe);
        }

        throw new Exception("Class without ExternClassAttribute cannot be processed!");

        static string? GetNamespace(INamedTypeSymbol symbol)
        {
            var @namespace = symbol.ContainingNamespace.ToDisplayString();
            if (@namespace == Helper.GLOBAL_NAMESPACE)
                @namespace = null;
            return @namespace;
        }
    }

    public static MethodInfo GetMethodInfo(IMethodSymbol method, bool hasDllImport, StringBuilder sb, AttributeData import, HashSet<string> usingNamespaces)
    {
        var dllName = (string)import.ConstructorArguments[0].Value!;
        var platform = (ImportPlatform)import.ConstructorArguments[1].Value!;
        var entryPoint = method.Name;
        CallingConvention callingConvention = CallingConvention.Cdecl;
        var isStatic = true;
        CharSet charSet = CharSet.Ansi;
        bool setLastError = false;

        //set method info from DllImportFor attribute
        foreach (var arg in import.NamedArguments)
        {
            switch (arg.Key)
            {
                case nameof(DllImportForAttribute.CallingConvention):
                    if (!arg.Value.IsNull)
                        callingConvention = (CallingConvention)arg.Value.Value!;
                    continue;
                case nameof(DllImportForAttribute.StaticCallMethod):
                    if (!arg.Value.IsNull)
                        isStatic = (bool)arg.Value.Value!;
                    continue;
                case nameof(DllImportForAttribute.EntryPoint):
                    if (!string.IsNullOrWhiteSpace((string?)arg.Value.Value))
                        entryPoint = (string)arg.Value.Value!;
                    continue;
                case nameof(DllImportAttribute.SetLastError):
                    setLastError = ((bool?)arg.Value.Value) ?? false;
                    continue;
                case nameof(DllImportAttribute.CharSet):
                    charSet = (CharSet)arg.Value.Value!;
                    continue;
                default:
                    continue;
            }
        }

        //if return type has any attributes, append them
        foreach (var atr in method.GetReturnTypeAttributes())
        {
            sb.Append(AttributeToSpan(atr, out var @namespace).ToString());
            sb.Append(", ");
        }

        var returnTypeAttributes = sb.ToString();
        var returnType = method.ReturnType.ToString();

        sb.Clear();
        Helper.AppendMethodParameters(method, sb);


        var methodParams = sb.ToString();
        sb.Clear();

        for (var i = 0; i < method.Parameters.Length; i++)
        {
            sb.Append(method.Parameters[i].RefKind switch
            {
                RefKind.None => "",
                RefKind.Ref => "ref ",
                RefKind.Out => "out ",
                RefKind.In => "in ",
                _ => ""
            });
            sb.Append(method.Parameters[i].Name);
            if (i != method.Parameters.Length - 1)
                sb.Append(", ");
        }
        var paramNames = sb.ToString();
        var methodInfo = new MethodInfo(method.Name,
                                        returnTypeAttributes,
                                        returnType,
                                        methodParams,
                                        dllName,
                                        entryPoint,
                                        platform,
                                        callingConvention,
                                        hasDllImport,
                                        import.ApplicationSyntaxReference!.Span,
                                        import.ApplicationSyntaxReference!.SyntaxTree.GetLineSpan(import.ApplicationSyntaxReference!.Span),
                                        false,
                                        isStatic,
                                        paramNames,
                                        charSet,
                                        setLastError);
        return methodInfo;
    }

    struct PlatformsEnumerator
    {
        CurrentPlatforms _platforms;
        int _state = -1;

        public ImportPlatform Current { get; private set; }

        public PlatformsEnumerator(CurrentPlatforms platforms)
        {
            _platforms = platforms;
        }

        public void Reset() => _state = -1;
        public bool MoveNext()
        {
            while (_state < 3)
            {
                _state++;
                if (_platforms.HasPlatform((ImportPlatform)_state))
                {
                    Current = (ImportPlatform)_state;
                    return true;
                }
            }
            return false;
        }

    }

    readonly record struct CurrentPlatforms
    {
        public readonly bool Win32;
        public readonly bool Win64;
        public readonly bool Linux64;
        public readonly bool Osx;

        public readonly int Count;

        public CurrentPlatforms(bool win32, bool win64, bool linux64, bool osx)
        {
            Span<bool> tmp = stackalloc bool[4];
            tmp[0] = Win32 = win32;
            tmp[1] = Win64 = win64;
            tmp[2] = Linux64 = linux64;
            tmp[3] = Osx = osx;
            var c = 0;
            foreach (var i in tmp)
            {
                if (i)
                    c++;
            }
            Count = c;
        }

        public readonly PlatformsEnumerator GetEnumerator() => new(this);

        public readonly ImportPlatform GetFirstPlatform()
        {
            if (Win32) return ImportPlatform.Win32;
            if (Win64) return ImportPlatform.Win64;
            if (Linux64) return ImportPlatform.Linux64;
            if (Osx) return ImportPlatform.Osx;
            throw new NotSupportedException();
        }

        public readonly bool HasOtherPlatforms(ImportPlatform platform)
        {
            return platform switch
            {
                ImportPlatform.Win32 => Win64 || Linux64 || Osx,
                ImportPlatform.Win64 => Win32 || Linux64 || Osx,
                ImportPlatform.Linux64 => Win32 || Win64 || Osx,
                ImportPlatform.Osx => Win32 || Win64 || Linux64,
                _ => false,
            };
        }

        public readonly bool HasPlatform(ImportPlatform platform)
        {
            return platform switch
            {
                ImportPlatform.Win32 => Win32,
                ImportPlatform.Win64 => Win64,
                ImportPlatform.Linux64 => Linux64,
                ImportPlatform.Osx => Osx,
            };
        }

        public readonly string ToOsPlatformString(ImportPlatform platform)
        {
            return platform switch
            {
                ImportPlatform.Win32 => nameof(OSPlatform.Windows),
                ImportPlatform.Win64 => nameof(OSPlatform.Windows),
                ImportPlatform.Linux64 => nameof(OSPlatform.Linux),
                ImportPlatform.Osx => nameof(OSPlatform.OSX),
            };
        }

        public readonly bool IsWindows32and64Only()
        {
            return Win32 && Win64 && !Linux64 && !Osx;
        }
    }
}
